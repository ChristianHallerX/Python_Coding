"""
924. Minimize Malware Spread (Hard)

(vaguely similar to Rotten Oranges but with extra logic to find islands/connected components)

You are given a network of 'n' nodes represented as an 'n' * 'n' adjacency matrix graph, where the
ith node is directly connected to the jth node if graph[i][j] == 1.

Some nodes 'initial' are initially infected by malware.
Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware,
both nodes will be infected by malware.
This spread of malware will continue until no more nodes can be infected in this manner.

Suppose 'M(initial)' is the final number of nodes infected with malware in the entire network after the
spread of malware stops.
We will remove exactly one node from 'initial'.

Return the node that, if removed, would minimize 'M(initial)'.
If multiple nodes could be removed to minimize 'M(initial)', return such a node with the smallest index.

Note that if a node was removed from the 'initial' list of infected nodes, it might still be infected later
due to the malware spread.
"""


def minMalwareSpread(graph: list[list[int]], initial: list[int]) -> int:
    """
    Intuition:
    ----------
    The problem can be viewed as identifying connected components in the network.
    Each connected component is a subgraph where all nodes are inter-connected.
    If any node in a component is initially infected, eventually the entire component becomes infected.

    Key idea:
    1. Use Union-Find to group nodes into connected components.
    2. For each component, count:
       - The total number of nodes (component size).
       - The number of initially infected nodes.
    3. If a component has exactly one initially infected node, then removing that node
       would prevent the entire component from being infected, effectively "saving" all those nodes.
    4. We choose the node whose removal would save the largest number of nodes.
       In case of a tie, the node with the smallest index is selected.
    5. If no node uniquely infects a component, return the smallest index from the initial list.

    Time Complexity: O(n**2) Double loop over matrix
    Space Complexity: O(n**2), parents list of size n, initCount and compSize dicts each O(n)
    """

    n = len(graph)

    # Initialize the union-find structure with each node being its own parent.
    parent = [i for i in range(n)]

    # Helper 1
    def find_root(x: int) -> int:
        # Recursively finds the root of x, applying path compression.
        if parent[x] != x:
            parent[x] = find_root(parent[x])
        return parent[x]

    # Helper 2
    def union(x: int, y: int) -> None:
        # Unites the sets containing x and y by connecting their roots and assigns parent nodes
        rootX, rootY = find_root(x), find_root(y)
        if rootX != rootY:
            parent[rootY] = rootX

    # Build connected components by unioning nodes that are directly connected.
    # We iterate over the upper triangle of the matrix (since the graph is symmetric).
    for i in range(n):
        for j in range(i + 1, n):
            if graph[i][j]:
                union(i, j)

    # Count the total number of nodes in each component.
    compSize = {}
    for i in range(n):
        root = find_root(i)
        compSize[root] = compSize.get(root, 0) + 1

    # Count the number of initially infected nodes in each component.
    initCount = {}
    for node in initial:
        root = find_root(node)
        initCount[root] = initCount.get(root, 0) + 1

    # Determine the best node to remove:
    # For each node in 'initial', if it's the only infected node in its component,
    # then removing it will prevent the entire component from being infected.
    bestNode = None  # Candidate node to remove
    bestSaved = 0  # Maximum number of nodes that can be saved

    # Find components with one infected initial and count the size of the saved nodes in the component
    # Sorting ensures that in case of a tie, the smallest index is chosen.
    for node in sorted(initial):
        root = find_root(node)
        if initCount[root] == 1:  # Only one infection in this component
            # The potential saving is the size of the component
            if compSize[root] > bestSaved:
                bestSaved = compSize[root]
                bestNode = node

    # If no node uniquely infects a component, return the smallest index from initial.
    if bestNode is None:
        return min(initial)

    return bestNode


def main():
    graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]
    initial = [0, 1]
    print(minMalwareSpread(graph, initial), "expected: 0")

    graph = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    initial = [0, 2]
    print(minMalwareSpread(graph, initial), "expected: 0")

    graph = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
    initial = [1, 2]
    print(minMalwareSpread(graph, initial), "expected: 1")


if __name__ == "__main__":
    main()

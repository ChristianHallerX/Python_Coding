"""
928. Minimize Malware Spread II (Hard)

You are given a network of 'n' nodes represented as an 'n' * 'n' adjacency matrix 'graph', where the
ith node is directly connected to the jth node if graph[i][j] == 1.

Some nodes 'initial' are initially infected by malware.

Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware,
both nodes will be infected by malware.

This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network after the
spread of malware stops.

We will remove exactly one node from 'initial', **completely removing it and any connections from this node
to any other node** (different from Minimize Malware Spread I).

Return the node that, if removed, would minimize M(initial) infections.
If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.
"""


def minMalwareSpread(graph: list[list[int]], initial: list[int]) -> int:
    """
    Find a configuration of node removals that minimizes infections -> find largest connected components without
    containing an initial infection. Does a removal create islands? Maximize uninfected island size.
    Simulate removing one initially infected node, spread infection, and count the remaining un-infected nodes.
    [1, 1, 0] = connected to itself, connection to node 1, connection to node 2

    Time Complexity: dfs O(n**2), simulation for each 'initial' removal k -> Total O(n**2 * k) = O(n**3)
    Space Complexity: visited list O(n)

    """
    n = len(graph)

    def simulate(removal) -> int:
        """
        Pass a node to remove from 'initial' and run dfs on infections
        removal (list of ints)    node passed to be removed from 'initial'
        Returns total number of nodes infected after spread, M(initial)
        """
        # init list that tracks infections and visits. False = uninfected, True = infected
        visited = [False] * n

        def dfs(node: int):

            # Skip the removed node
            if node == removal:
                return

            # Mark the current node as infected (visited)
            visited[node] = True

            # Traverse all possible neighboring nodes
            for nei in range(n):
                # If the neighbor is the removed node or is already infected, skip it
                if nei == removal or visited[nei]:
                    continue
                # If there's a direct connection from the current node to the neighbor,
                # simulate infection spread by recursing on the neighbor.
                if graph[node][nei] == 1:
                    dfs(nei)

        # Start DFS from 'initial' nodes if not the removal or already visited
        for node in initial:
            if node == removal:
                continue
            if not visited[node]:
                dfs(node)

        # Count of infections (count True on list)
        return sum(visited)

    best_node = None  # This will hold the best candidate node to remove.
    best_infected = float("inf")  # Initialize with infinity for comparison.

    # Simulate infection for each initial node removal and update 'best_infected' if lower value
    for node in sorted(initial):
        count = simulate(node)
        if count < best_infected:
            best_infected = count
            best_node = node

    return best_node


def main():
    graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]
    initial = [0, 1]
    print(minMalwareSpread(graph, initial), "expected: 0")

    graph = [[1, 1, 0], [1, 1, 1], [0, 1, 1]]
    initial = [0, 1]
    print(minMalwareSpread(graph, initial), "expected: 1")

    graph = [[1, 1, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1]]
    initial = [0, 1]
    print(minMalwareSpread(graph, initial), "expected: 1")


if __name__ == "__main__":
    main()
